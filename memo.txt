# センチネル文字のルール

（YYFILL = 0 かつ re2c:eof 無効なルール）
は基本的に `goto loop;` で先頭に戻ったあと、一番最初の switch にセンチネル文字判定がくる
センチネル文字もだった場合は 番兵ルールに goto してレキサーが終了する。


- sentinel_character.c
- sentinel_character_2.c


---------------------------------------------------------------------------


# 境界チェック付きセンチネル文字ルール


レキサーの初期状態（開始状態）に以下のチェックコードが挿入される

- YYLIMIT がバッファの末尾アドレス、YYCURSORが現在のカーソル位置
  - カーソルがバッファの末尾を超えたときに初期状態が受け付けない文字がきたかどうか
  - つまり入力がバッファ内完全に収まる場合に良いだろうか（？)

```c
default:
	// 初期状態での境界チェック
	if (YYLIMIT <= YYCURSOR) goto yyeof1;
	// 境界チェックに失敗している場合は不正な文字が来たと判断する
	goto yy2;
}
```

この設定に

```
re2c:yyfill:enable = 1;
re2c:define:YYFILL = "...";
```

を追加すると「YYFILL + EOF のルール」(yyfill_with_sentinel_character)になる


- sentinel_with_bound_check.c


---------------------------------------------------------------------------


# パディング付き境界チェック方

EOFじゃないほうの、センチネル文字をつかう。
YYFILLを有効にしている
つまり
- `re2c:eof = -1` かつ `re2c:yyfill:enable = 1` である場合


このとき生成されるコードは、レキサーのオートマトンが遷移するごとに以下のようにYYFILLコードが挿入される

```c
yy6: // [ ]+  { goto loop; }
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) return -1; // YYFILL
	yych = *YYCURSOR;
	switch (yych) {
	case ' ':	goto yy6;
	default:	goto yy8;
	}
```

つまり、遷移するごとに現在位置がYYLIMITに達しているかチェックしている



最後、センチネル文字でのルールで、以下のように確認している
- (現在のカーソル位置+YYMAXFILL-1) が YYLIMIT と等しいか?

```c
	{ return YYCURSOR + YYMAXFILL - 1 == YYLIMIT ? count : -1; }
```



これらのルールは以下のようなセンチネル文字をパディングするユーティリティ関数の存在が前提となっている。

```c
// make a copy of the string with YYMAXFILL zeroes at the end
// 入力文字列の最後にYYMAXFILLの分だけ\0をパディングした文字列のコピーを作成する
static void test(const char *str, unsigned int len, int res)
{
    char *s = (char*) malloc(len + YYMAXFILL);
    memcpy(s, str, len);
    memset(s + len, 0, YYMAXFILL); // YYMAXFILL分\0を末尾にパディングセットしている
    int r = lex(s, len);
    free(s);
    assert(r == res);
}
```

- bound_check_with_padding.c


---------------------------------------------------------------------------


# 汎用APIによるカスタムメソッド

このソースコード例では「sentinel_with_bound_check.re.c」と同じ処理方法だが、
生成されるC言語のコードがそれぞれ自分で定義した処理に置き換わっている。
どの部分をカスタマイズしたいのかを比較すれば、どのように変更したいかが把握しやすくなるだろう。



- custom_method_with_generic_api.c



---------------------------------------------------------------------------
次からはYYFILLの動作についてのサンプルソース
---------------------------------------------------------------------------



# YYFILL + EOF のルール
バッファ再充填ありでEOFルールが有効な場合
これはつまり入力がバッファに収まらない可能性がある入力で終端文字があるという想定

このとき一番最初の状態のみ `goto yyeof1` があって最終状態まで行けるのは「センチネル文字」と同じだが
センチネル文字の判定が以下のようになっている。

```c
yyFillLabel0:
	yych = *in->cur;
	switch (yych) {
	case ' ':	goto yy4;
	case '\'':	goto yy7;
	default:
		/* 受諾できる文字以外のものが来た場合に yyfill チェック */
		if (in->lim <= in->cur) {
			/* yyfill が成功 = 新しい文字が充填されたので再度チェックするため戻る */
			if (fill(in) == 0) goto yyFillLabel0;
			/* 初期状態でのEOFルール適用 */
			goto yyeof1;
		}
		goto yy2;
	}
```

つまり YYFILL が呼ばれる条件（YYLIMIT）に引っかかっており、YYFILL が失敗したとき
受諾される文字が来ず、バッファ再充填がされなかったとき、レキサーを正常終了させるという動作になる。


- yyfill_with_sentinel_character.c


---------------------------------------------------------------------------


# YYFILL + パディング
- EOFルールじゃないほうのセンチネル文字を使うパターン
- バッファ再充填あり


サンプルソースは YYFILL に失敗したら `return -1` して即座に失敗する
この場合で生成されるソースコードは以下のようになる
- 文字を読み込む度に YYLIMIT のチェックが行われる
  - YYFILL が成功しても `goto yyFillLabel0;` のような処理が行われず、そのままマッチング処理に入る
- `yyfill_with_sentinel_character` との違いは、`default`節で失敗したときに YYLIMITチェックが入るのではなく、文字読み込みの度にYYLIMITチェックが入る点


```c
 yy6: // [ ]+   { goto loop; }
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1; // YYFILL
	yych = *in->cur;
	switch (yych) {
	case ' ':	goto yy6;
	default:	goto yy8;
	}                      
```


- yyfill_with_padding.c


---------------------------------------------------------------------------
---------------------------------------------------------------------------


# Storable State
`-f` または `--storable-state` オプションを忘れると変なコードが出力される。

`/*!getstate:re2c*/` の箇所が以下のように置換される
- `re2c:define:YYGETSTATE` から取得できる状態変数からステートマシンの状態へ goto する

```c
    switch (in->state) {
default:
	goto yy0; // 初期状態へ
case 0:
	if (in->lim <= in->cur) goto yyeof1;
	goto yyFillLabel0;
case 1:
	if (in->lim <= in->cur) goto yy4;
	goto yyFillLabel1;
case 2:
	if (in->lim <= in->cur) goto yy10;
	goto yyFillLabel2;
}
```


```c
	default:
		if (in->lim <= in->cur) {
			in->state = 1;  // YYSETSTATE
			return WAITING; // YYFILL の置換結果がこうなる
		}
		goto yy4;
	}
```


- storable_state.c

---------------------------------------------------------------------------





['] ([^'\\] | [\\][^])* [']
これは引用符でかこまれた、'か\以外の任意の位置文字、または\ ^ のいずれかで構成された文字列を表す。








以下の通り sentinel_with_bound_check とはつまり YYFILL を無効にした EOF ルールのこと

EOF without YYFILL
```c
	default:
		if (YYLIMIT <= YYCURSOR) goto yyeof1;
		goto yy2;
	}
```


EOF + YYFILL
```c
	default:
		if (YYLIMIT <= YYCURSOR) {
			if (YYFILL() == 0) goto yyFillLabel0;
			goto yyeof1;
		}
		goto yy2;
	}
yy2:
```